### 当下的问题

- 开发、测试、生产等环境的不同可能导致应用程序运行的结果有所不同，甚至会出现错误：
    - 如：各环境中的JDK、Tomcat、MySQL等版本各有不同；  
    - 在JDK1.6中写的代码可能在JDK1.8中已经Deprecated了；  
    - 在JDK1.8中写的代码可能在JDK1.6中还不支持。
    
- 需要在一个项目的多个版本中进行切换时很不方便，项目转移服务器时很不方便：
    - 如有一个博客，在1.0这个版本中不允许网友发博文，在2.0这个版本中允许网友发博文，在运行了2.0版本一段时间后需要切换到1.0时就相对较麻烦（除非在服务器上存有多个版本）；  
    - 当需要将此博客网站移到其他服务器是显得有些麻烦，特别是转移后还有可能需要在多个版本中切换使用，转移过程也可能会导致数据丢失或操作错误等问题。

- 多人使用同一台服务器时的尴尬问题难以解决：
    - 多人使用同一服务器的问题最为严重，因为每个人的开发环境都有可能不同，各种服务工具的版本不统一问题、各种配置习惯不统一的问题等；  
    - 在服务器运维过程中很难同时满足诸多开发者的不同需求；  
    - 也很难在同一服务器上安装多个不同版本的JDK、Tomcat、MySQL等；
    - 也很难在同一服务器上争用同一个端口号；

### Docker的诞生可以很轻松的解决上述的各种问题，并且Docker的作用远不止这些。

- 先来看一下在Docker中的几个比较关键的组件：
    - 容器 - Docker运行的最小单位：
    - 每个容器都是一个轻量级的虚拟机；
    - 每个容器都拥有独立的root文件系统、网络服务、进程服务等
    - 容器与容器之间可以互不干扰，容器不会关心其他容器内部运行的是什么东西，所以通过容器可以让一台服务器内安装不同版本的JDK、Tomcat等（只要运行在不同的容器内部即可）；
    - 一般一个容器只干一件事情，如：一个容器内只运行Tomcat，另一容器内只运行MySQL。
    
- 镜像 - 用于产生容器：
    - 一个镜像可以产生很多容器；
    - 镜像可以在本地创建，创建成功后即可启动容器运行；
    - 可以将镜像推送（push）到Registry（仓库）中；
    - 可以将Registry（仓库）中的镜像拉取（pull）到本地。
    
- Registry（仓库）- 用于存放镜像：
    - Registry可以是官方的，也可以是国内知名的（如阿里云的），也可以是私有的；
    - 由于仓库在远程，所以为应用程序的移植提供的便利。
    
### 八个Docker的真实应用场景    
1、 简化配置
> 这是Docker公司宣传的Docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。

2、 代码流水线（Code Pipeline）管理
> 前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。

3、 提高开发效率
> 这就带来了一些额外的好处：Docker能提升开发者的开发效率。如果你想看一个详细一点的例子，可以参考Aater在
[DevOpsDays Austin 2014 大会](http://www.slideshare.net/Flux7Labs/using-docker-to-improve-web-developer-productivity-dev-opsdays-austin-may-5)
或者是DockerCon上的演讲。
  
> 不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。 
 
> 理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。

4、 隔离应用
> 有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。
我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（译者注：微服务架构）。如果你想了解为什么松耦合的应用这么重要，请参考Steve Yege的这篇论文，文中将Google和亚马逊做了比较。

5、 整合服务器
> 正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。

6、 调试能力
> Docker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在
[《Docker拯救世界》](http://flux7.com/blogs/docker/docker-saves-the-day-at-flux7/)
的文章中找到这一点的例证。

7、 多租户环境
> 另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为IoT（译者注：物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。
使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。

8、 快速部署
> 在虚拟机之前，引入新的硬件资源需要消耗几天的时间。虚拟化技术（Virtualization）将这个时间缩短到了分钟级别。而Docker通过为进程仅仅创建一个容器而无需启动一个操作系统，再次将这个过程缩短到了秒级。这正是Google和Facebook都看重的特性。


### 参考
[Docker 背后的内核知识——Namespace 资源隔离](https://www.infoq.cn/article/docker-kernel-knowledge-namespace-resource-isolation/)
[8 Ways to Use Docker in the Real World – Flux7 Blog](https://www.flux7.com/blog/8-ways-to-use-docker-in-the-real-world-flux7-blog/)

